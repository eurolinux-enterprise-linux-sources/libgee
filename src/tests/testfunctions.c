/* testfunctions.c generated by valac 0.36.11, the Vala compiler
 * generated from testfunctions.vala, do not modify */

/* testfunctions.vala
 *
 * Copyright (C) 2010  Maciej Piechotka
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Maciej Piechotka <uzytkownik2@gmail.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define GEE_TYPE_TEST_CASE (gee_test_case_get_type ())
#define GEE_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_TEST_CASE, GeeTestCase))
#define GEE_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_TEST_CASE, GeeTestCaseClass))
#define GEE_IS_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_TEST_CASE))
#define GEE_IS_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_TEST_CASE))
#define GEE_TEST_CASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_TEST_CASE, GeeTestCaseClass))

typedef struct _GeeTestCase GeeTestCase;
typedef struct _GeeTestCaseClass GeeTestCaseClass;
typedef struct _GeeTestCasePrivate GeeTestCasePrivate;

#define TYPE_FUNCTIONS_TESTS (functions_tests_get_type ())
#define FUNCTIONS_TESTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FUNCTIONS_TESTS, FunctionsTests))
#define FUNCTIONS_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FUNCTIONS_TESTS, FunctionsTestsClass))
#define IS_FUNCTIONS_TESTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FUNCTIONS_TESTS))
#define IS_FUNCTIONS_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FUNCTIONS_TESTS))
#define FUNCTIONS_TESTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FUNCTIONS_TESTS, FunctionsTestsClass))

typedef struct _FunctionsTests FunctionsTests;
typedef struct _FunctionsTestsClass FunctionsTestsClass;
typedef struct _FunctionsTestsPrivate FunctionsTestsPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define FUNCTIONS_TESTS_TYPE_MY_COMPARABLE (functions_tests_my_comparable_get_type ())
#define FUNCTIONS_TESTS_MY_COMPARABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparable))
#define FUNCTIONS_TESTS_MY_COMPARABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparableClass))
#define FUNCTIONS_TESTS_IS_MY_COMPARABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE))
#define FUNCTIONS_TESTS_IS_MY_COMPARABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE))
#define FUNCTIONS_TESTS_MY_COMPARABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparableClass))

typedef struct _FunctionsTestsMyComparable FunctionsTestsMyComparable;
typedef struct _FunctionsTestsMyComparableClass FunctionsTestsMyComparableClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define FUNCTIONS_TESTS_TYPE_MY_HASHABLE (functions_tests_my_hashable_get_type ())
#define FUNCTIONS_TESTS_MY_HASHABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashable))
#define FUNCTIONS_TESTS_MY_HASHABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashableClass))
#define FUNCTIONS_TESTS_IS_MY_HASHABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FUNCTIONS_TESTS_TYPE_MY_HASHABLE))
#define FUNCTIONS_TESTS_IS_MY_HASHABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FUNCTIONS_TESTS_TYPE_MY_HASHABLE))
#define FUNCTIONS_TESTS_MY_HASHABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashableClass))

typedef struct _FunctionsTestsMyHashable FunctionsTestsMyHashable;
typedef struct _FunctionsTestsMyHashableClass FunctionsTestsMyHashableClass;
typedef struct _Block8Data Block8Data;
typedef struct _Block9Data Block9Data;
typedef struct _Block10Data Block10Data;
typedef struct _Block11Data Block11Data;
typedef struct _FunctionsTestsMyComparablePrivate FunctionsTestsMyComparablePrivate;
typedef struct _FunctionsTestsMyHashablePrivate FunctionsTestsMyHashablePrivate;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _GeeTestCase {
	GObject parent_instance;
	GeeTestCasePrivate * priv;
};

struct _GeeTestCaseClass {
	GObjectClass parent_class;
	void (*set_up) (GeeTestCase* self);
	void (*tear_down) (GeeTestCase* self);
};

struct _FunctionsTests {
	GeeTestCase parent_instance;
	FunctionsTestsPrivate * priv;
};

struct _FunctionsTestsClass {
	GeeTestCaseClass parent_class;
};

typedef void (*GeeTestCaseTestMethod) (void* user_data);
struct _Block8Data {
	int _ref_count_;
	FunctionsTests* self;
	gint i;
	gint j;
};

struct _Block9Data {
	int _ref_count_;
	Block8Data * _data8_;
	gint k;
};

struct _Block10Data {
	int _ref_count_;
	FunctionsTests* self;
	gint i;
};

struct _Block11Data {
	int _ref_count_;
	Block10Data * _data10_;
	gint j;
	gint start;
};

struct _FunctionsTestsMyComparable {
	GObject parent_instance;
	FunctionsTestsMyComparablePrivate * priv;
};

struct _FunctionsTestsMyComparableClass {
	GObjectClass parent_class;
};

struct _FunctionsTestsMyComparablePrivate {
	gint i;
};

struct _FunctionsTestsMyHashable {
	GObject parent_instance;
	FunctionsTestsMyHashablePrivate * priv;
};

struct _FunctionsTestsMyHashableClass {
	GObjectClass parent_class;
};

struct _FunctionsTestsMyHashablePrivate {
	gint i;
};


static gpointer functions_tests_parent_class = NULL;
static gpointer functions_tests_my_comparable_parent_class = NULL;
static GeeComparableIface * functions_tests_my_comparable_gee_comparable_parent_iface = NULL;
static gpointer functions_tests_my_hashable_parent_class = NULL;
static GeeComparableIface * functions_tests_my_hashable_gee_comparable_parent_iface = NULL;
static GeeHashableIface * functions_tests_my_hashable_gee_hashable_parent_iface = NULL;

GType gee_test_case_get_type (void) G_GNUC_CONST;
GType functions_tests_get_type (void) G_GNUC_CONST;
enum  {
	FUNCTIONS_TESTS_0_PROPERTY
};
FunctionsTests* functions_tests_new (void);
FunctionsTests* functions_tests_construct (GType object_type);
GeeTestCase* gee_test_case_construct (GType object_type, const gchar* name);
void gee_test_case_add_test (GeeTestCase* self, const gchar* name, GeeTestCaseTestMethod test, void* test_target, GDestroyNotify test_target_destroy_notify);
void functions_tests_test_string_func (FunctionsTests* self);
static void _functions_tests_test_string_func_gee_test_case_test_method (gpointer self);
void functions_tests_test_int_func (FunctionsTests* self);
static void _functions_tests_test_int_func_gee_test_case_test_method (gpointer self);
void functions_tests_test_compare_func (FunctionsTests* self);
static void _functions_tests_test_compare_func_gee_test_case_test_method (gpointer self);
void functions_tests_test_hash_func (FunctionsTests* self);
static void _functions_tests_test_hash_func_gee_test_case_test_method (gpointer self);
void functions_tests_test_unfold (FunctionsTests* self);
static void _functions_tests_test_unfold_gee_test_case_test_method (gpointer self);
void functions_tests_test_concat (FunctionsTests* self);
static void _functions_tests_test_concat_gee_test_case_test_method (gpointer self);
static GType functions_tests_my_comparable_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static FunctionsTestsMyComparable* functions_tests_my_comparable_new (gint i);
static FunctionsTestsMyComparable* functions_tests_my_comparable_construct (GType object_type, gint i);
static GType functions_tests_my_hashable_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static FunctionsTestsMyHashable* functions_tests_my_hashable_new (gint i);
static FunctionsTestsMyHashable* functions_tests_my_hashable_construct (GType object_type, gint i);
static Block8Data* block8_data_ref (Block8Data* _data8_);
static void block8_data_unref (void * _userdata_);
static GeeLazy* __lambda54_ (Block8Data* _data8_);
static Block9Data* block9_data_ref (Block9Data* _data9_);
static void block9_data_unref (void * _userdata_);
static gint __lambda55_ (Block9Data* _data9_);
static gpointer ___lambda55__gee_lazy_func (gpointer self);
static GeeLazy* ___lambda54__gee_unfold_func (gpointer self);
static Block10Data* block10_data_ref (Block10Data* _data10_);
static void block10_data_unref (void * _userdata_);
static GeeLazy* __lambda56_ (Block10Data* _data10_);
static Block11Data* block11_data_ref (Block11Data* _data11_);
static void block11_data_unref (void * _userdata_);
static GeeLazy* __lambda57_ (Block11Data* _data11_);
static GeeLazy* ___lambda57__gee_unfold_func (gpointer self);
static GeeLazy* ___lambda56__gee_unfold_func (gpointer self);
#define FUNCTIONS_TESTS_MY_COMPARABLE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparablePrivate))
enum  {
	FUNCTIONS_TESTS_MY_COMPARABLE_0_PROPERTY
};
static gint functions_tests_my_comparable_real_compare_to (GeeComparable* base, FunctionsTestsMyComparable* cmp);
static void functions_tests_my_comparable_finalize (GObject * obj);
#define FUNCTIONS_TESTS_MY_HASHABLE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashablePrivate))
enum  {
	FUNCTIONS_TESTS_MY_HASHABLE_0_PROPERTY
};
static gint functions_tests_my_hashable_real_compare_to (GeeComparable* base, FunctionsTestsMyHashable* cmp);
static guint functions_tests_my_hashable_real_hash (GeeHashable* base);
static gboolean functions_tests_my_hashable_real_equal_to (GeeHashable* base, FunctionsTestsMyHashable* hash);
static void functions_tests_my_hashable_finalize (GObject * obj);


static void _functions_tests_test_string_func_gee_test_case_test_method (gpointer self) {
	functions_tests_test_string_func ((FunctionsTests*) self);
}


static void _functions_tests_test_int_func_gee_test_case_test_method (gpointer self) {
	functions_tests_test_int_func ((FunctionsTests*) self);
}


static void _functions_tests_test_compare_func_gee_test_case_test_method (gpointer self) {
	functions_tests_test_compare_func ((FunctionsTests*) self);
}


static void _functions_tests_test_hash_func_gee_test_case_test_method (gpointer self) {
	functions_tests_test_hash_func ((FunctionsTests*) self);
}


static void _functions_tests_test_unfold_gee_test_case_test_method (gpointer self) {
	functions_tests_test_unfold ((FunctionsTests*) self);
}


static void _functions_tests_test_concat_gee_test_case_test_method (gpointer self) {
	functions_tests_test_concat ((FunctionsTests*) self);
}


FunctionsTests* functions_tests_construct (GType object_type) {
	FunctionsTests * self = NULL;
	self = (FunctionsTests*) gee_test_case_construct (object_type, "Functions");
	gee_test_case_add_test ((GeeTestCase*) self, "[Functions] comparing and hashing strings", _functions_tests_test_string_func_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Functions] comparing and hashing int", _functions_tests_test_int_func_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Functions] comparing instances of Comparable", _functions_tests_test_compare_func_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Functions] comparing and hashing instances of Hashable", _functions_tests_test_hash_func_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Iterator] unfold", _functions_tests_test_unfold_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Iterator] concat", _functions_tests_test_concat_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	return self;
}


FunctionsTests* functions_tests_new (void) {
	return functions_tests_construct (TYPE_FUNCTIONS_TESTS);
}


void functions_tests_test_string_func (FunctionsTests* self) {
	gchar* one = NULL;
	gchar* _tmp0_;
	gchar* two = NULL;
	gchar* _tmp1_;
	gchar* two_copy = NULL;
	gchar* _tmp2_;
	GeeEqualDataFunc eq = NULL;
	void* _tmp3_;
	GDestroyNotify _tmp4_;
	GeeEqualDataFunc _tmp5_;
	void* eq_target;
	GDestroyNotify eq_target_destroy_notify;
	GCompareDataFunc cmp = NULL;
	void* _tmp6_;
	GDestroyNotify _tmp7_;
	GCompareDataFunc _tmp8_;
	void* cmp_target;
	GDestroyNotify cmp_target_destroy_notify;
	GeeHashDataFunc hash = NULL;
	void* _tmp9_;
	GDestroyNotify _tmp10_;
	GeeHashDataFunc _tmp11_;
	void* hash_target;
	GDestroyNotify hash_target_destroy_notify;
	gboolean _tmp12_;
	gint _tmp13_;
	guint _tmp14_;
	guint _tmp15_;
	gboolean _tmp16_;
	gint _tmp17_;
	guint _tmp18_;
	guint _tmp19_;
	gboolean _tmp20_;
	gint _tmp21_;
	gboolean _tmp22_;
	gint _tmp23_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup ("one");
	one = _tmp0_;
	_tmp1_ = g_strdup ("two");
	two = _tmp1_;
	_tmp2_ = g_strdup (two);
	two_copy = _tmp2_;
	_tmp5_ = gee_functions_get_equal_func_for (G_TYPE_STRING, &_tmp3_, &_tmp4_);
	eq = _tmp5_;
	eq_target = _tmp3_;
	eq_target_destroy_notify = _tmp4_;
	_tmp8_ = gee_functions_get_compare_func_for (G_TYPE_STRING, &_tmp6_, &_tmp7_);
	cmp = _tmp8_;
	cmp_target = _tmp6_;
	cmp_target_destroy_notify = _tmp7_;
	_tmp11_ = gee_functions_get_hash_func_for (G_TYPE_STRING, &_tmp9_, &_tmp10_);
	hash = _tmp11_;
	hash_target = _tmp9_;
	hash_target_destroy_notify = _tmp10_;
	_vala_assert (eq != NULL, "eq != null");
	_vala_assert (cmp != NULL, "cmp != null");
	_vala_assert (hash != NULL, "hash != null");
	_tmp12_ = eq (two, two, eq_target);
	_vala_assert (_tmp12_, "eq (two, two)");
	_tmp13_ = cmp (two, two, cmp_target);
	_vala_assert (_tmp13_ == 0, "cmp (two, two) == 0");
	_tmp14_ = hash (two, hash_target);
	_tmp15_ = hash (two, hash_target);
	_vala_assert (_tmp14_ == _tmp15_, "hash (two) == hash (two)");
	_tmp16_ = eq (two, two_copy, eq_target);
	_vala_assert (_tmp16_, "eq (two, two_copy)");
	_tmp17_ = cmp (two, two_copy, cmp_target);
	_vala_assert (_tmp17_ == 0, "cmp (two, two_copy) == 0");
	_tmp18_ = hash (two, hash_target);
	_tmp19_ = hash (two_copy, hash_target);
	_vala_assert (_tmp18_ == _tmp19_, "hash (two) == hash (two_copy)");
	_tmp20_ = eq (one, two, eq_target);
	_vala_assert (!_tmp20_, "!eq (one, two)");
	_tmp21_ = cmp (one, two, cmp_target);
	_vala_assert (_tmp21_ < 0, "cmp (one, two) < 0");
	_tmp22_ = eq (two, one, eq_target);
	_vala_assert (!_tmp22_, "!eq (two, one)");
	_tmp23_ = cmp (two, one, cmp_target);
	_vala_assert (_tmp23_ > 0, "cmp (two, one) > 0");
	(hash_target_destroy_notify == NULL) ? NULL : (hash_target_destroy_notify (hash_target), NULL);
	hash = NULL;
	hash_target = NULL;
	hash_target_destroy_notify = NULL;
	(cmp_target_destroy_notify == NULL) ? NULL : (cmp_target_destroy_notify (cmp_target), NULL);
	cmp = NULL;
	cmp_target = NULL;
	cmp_target_destroy_notify = NULL;
	(eq_target_destroy_notify == NULL) ? NULL : (eq_target_destroy_notify (eq_target), NULL);
	eq = NULL;
	eq_target = NULL;
	eq_target_destroy_notify = NULL;
	_g_free0 (two_copy);
	_g_free0 (two);
	_g_free0 (one);
}


void functions_tests_test_int_func (FunctionsTests* self) {
	void* one = NULL;
	void* two = NULL;
	GeeEqualDataFunc eq = NULL;
	void* _tmp0_;
	GDestroyNotify _tmp1_;
	GeeEqualDataFunc _tmp2_;
	void* eq_target;
	GDestroyNotify eq_target_destroy_notify;
	GCompareDataFunc cmp = NULL;
	void* _tmp3_;
	GDestroyNotify _tmp4_;
	GCompareDataFunc _tmp5_;
	void* cmp_target;
	GDestroyNotify cmp_target_destroy_notify;
	GeeHashDataFunc hash = NULL;
	void* _tmp6_;
	GDestroyNotify _tmp7_;
	GeeHashDataFunc _tmp8_;
	void* hash_target;
	GDestroyNotify hash_target_destroy_notify;
	gboolean _tmp9_;
	gint _tmp10_;
	guint _tmp11_;
	guint _tmp12_;
	gboolean _tmp13_;
	gint _tmp14_;
	gboolean _tmp15_;
	gint _tmp16_;
	g_return_if_fail (self != NULL);
	one = (void*) 1;
	two = (void*) 2;
	_tmp2_ = gee_functions_get_equal_func_for (G_TYPE_INT, &_tmp0_, &_tmp1_);
	eq = _tmp2_;
	eq_target = _tmp0_;
	eq_target_destroy_notify = _tmp1_;
	_tmp5_ = gee_functions_get_compare_func_for (G_TYPE_INT, &_tmp3_, &_tmp4_);
	cmp = _tmp5_;
	cmp_target = _tmp3_;
	cmp_target_destroy_notify = _tmp4_;
	_tmp8_ = gee_functions_get_hash_func_for (G_TYPE_INT, &_tmp6_, &_tmp7_);
	hash = _tmp8_;
	hash_target = _tmp6_;
	hash_target_destroy_notify = _tmp7_;
	_vala_assert (eq != NULL, "eq != null");
	_vala_assert (cmp != NULL, "cmp != null");
	_vala_assert (hash != NULL, "hash != null");
	_tmp9_ = eq (two, two, eq_target);
	_vala_assert (_tmp9_, "eq (two, two)");
	_tmp10_ = cmp (two, two, cmp_target);
	_vala_assert (_tmp10_ == 0, "cmp (two, two) == 0");
	_tmp11_ = hash (two, hash_target);
	_tmp12_ = hash (two, hash_target);
	_vala_assert (_tmp11_ == _tmp12_, "hash (two) == hash (two)");
	_tmp13_ = eq (one, two, eq_target);
	_vala_assert (!_tmp13_, "!eq (one, two)");
	_tmp14_ = cmp (one, two, cmp_target);
	_vala_assert (_tmp14_ < 0, "cmp (one, two) < 0");
	_tmp15_ = eq (two, one, eq_target);
	_vala_assert (!_tmp15_, "!eq (two, one)");
	_tmp16_ = cmp (two, one, cmp_target);
	_vala_assert (_tmp16_ > 0, "cmp (two, one) > 0");
	(hash_target_destroy_notify == NULL) ? NULL : (hash_target_destroy_notify (hash_target), NULL);
	hash = NULL;
	hash_target = NULL;
	hash_target_destroy_notify = NULL;
	(cmp_target_destroy_notify == NULL) ? NULL : (cmp_target_destroy_notify (cmp_target), NULL);
	cmp = NULL;
	cmp_target = NULL;
	cmp_target_destroy_notify = NULL;
	(eq_target_destroy_notify == NULL) ? NULL : (eq_target_destroy_notify (eq_target), NULL);
	eq = NULL;
	eq_target = NULL;
	eq_target_destroy_notify = NULL;
}


void functions_tests_test_compare_func (FunctionsTests* self) {
	FunctionsTestsMyComparable* two = NULL;
	FunctionsTestsMyComparable* _tmp0_;
	FunctionsTestsMyComparable* one = NULL;
	FunctionsTestsMyComparable* _tmp1_;
	FunctionsTestsMyComparable* two_copy = NULL;
	FunctionsTestsMyComparable* _tmp2_;
	GeeEqualDataFunc eq = NULL;
	void* _tmp3_;
	GDestroyNotify _tmp4_;
	GeeEqualDataFunc _tmp5_;
	void* eq_target;
	GDestroyNotify eq_target_destroy_notify;
	GCompareDataFunc cmp = NULL;
	void* _tmp6_;
	GDestroyNotify _tmp7_;
	GCompareDataFunc _tmp8_;
	void* cmp_target;
	GDestroyNotify cmp_target_destroy_notify;
	gboolean _tmp9_;
	gint _tmp10_;
	gboolean _tmp11_;
	gint _tmp12_;
	gboolean _tmp13_;
	gint _tmp14_;
	gboolean _tmp15_;
	gint _tmp16_;
	g_return_if_fail (self != NULL);
	_tmp0_ = functions_tests_my_comparable_new (2);
	two = _tmp0_;
	_tmp1_ = functions_tests_my_comparable_new (1);
	one = _tmp1_;
	_tmp2_ = functions_tests_my_comparable_new (2);
	two_copy = _tmp2_;
	_tmp5_ = gee_functions_get_equal_func_for (FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, &_tmp3_, &_tmp4_);
	eq = _tmp5_;
	eq_target = _tmp3_;
	eq_target_destroy_notify = _tmp4_;
	_tmp8_ = gee_functions_get_compare_func_for (FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, &_tmp6_, &_tmp7_);
	cmp = _tmp8_;
	cmp_target = _tmp6_;
	cmp_target_destroy_notify = _tmp7_;
	_vala_assert (eq != NULL, "eq != null");
	_vala_assert (cmp != NULL, "cmp != null");
	_tmp9_ = eq (two, two, eq_target);
	_vala_assert (_tmp9_, "eq (two, two)");
	_tmp10_ = cmp (two, two, cmp_target);
	_vala_assert (_tmp10_ == 0, "cmp (two, two) == 0");
	_tmp11_ = eq (two, two_copy, eq_target);
	_vala_assert (_tmp11_, "eq (two, two_copy)");
	_tmp12_ = cmp (two, two_copy, cmp_target);
	_vala_assert (_tmp12_ == 0, "cmp (two, two_copy) == 0");
	_tmp13_ = eq (one, two, eq_target);
	_vala_assert (!_tmp13_, "!eq (one, two)");
	_tmp14_ = cmp (one, two, cmp_target);
	_vala_assert (_tmp14_ < 0, "cmp (one, two) < 0");
	_tmp15_ = eq (two, one, eq_target);
	_vala_assert (!_tmp15_, "!eq (two, one)");
	_tmp16_ = cmp (two, one, cmp_target);
	_vala_assert (_tmp16_ > 0, "cmp (two, one) > 0");
	(cmp_target_destroy_notify == NULL) ? NULL : (cmp_target_destroy_notify (cmp_target), NULL);
	cmp = NULL;
	cmp_target = NULL;
	cmp_target_destroy_notify = NULL;
	(eq_target_destroy_notify == NULL) ? NULL : (eq_target_destroy_notify (eq_target), NULL);
	eq = NULL;
	eq_target = NULL;
	eq_target_destroy_notify = NULL;
	_g_object_unref0 (two_copy);
	_g_object_unref0 (one);
	_g_object_unref0 (two);
}


void functions_tests_test_hash_func (FunctionsTests* self) {
	FunctionsTestsMyHashable* two = NULL;
	FunctionsTestsMyHashable* _tmp0_;
	FunctionsTestsMyHashable* one = NULL;
	FunctionsTestsMyHashable* _tmp1_;
	FunctionsTestsMyHashable* two_copy = NULL;
	FunctionsTestsMyHashable* _tmp2_;
	FunctionsTestsMyHashable* minus_one = NULL;
	FunctionsTestsMyHashable* _tmp3_;
	FunctionsTestsMyHashable* minus_one2 = NULL;
	FunctionsTestsMyHashable* _tmp4_;
	GeeEqualDataFunc eq = NULL;
	void* _tmp5_;
	GDestroyNotify _tmp6_;
	GeeEqualDataFunc _tmp7_;
	void* eq_target;
	GDestroyNotify eq_target_destroy_notify;
	GCompareDataFunc cmp = NULL;
	void* _tmp8_;
	GDestroyNotify _tmp9_;
	GCompareDataFunc _tmp10_;
	void* cmp_target;
	GDestroyNotify cmp_target_destroy_notify;
	GeeHashDataFunc hash = NULL;
	void* _tmp11_;
	GDestroyNotify _tmp12_;
	GeeHashDataFunc _tmp13_;
	void* hash_target;
	GDestroyNotify hash_target_destroy_notify;
	gboolean _tmp14_;
	gint _tmp15_;
	guint _tmp16_;
	guint _tmp17_;
	gboolean _tmp18_;
	gint _tmp19_;
	guint _tmp20_;
	guint _tmp21_;
	gboolean _tmp22_;
	gint _tmp23_;
	gboolean _tmp24_;
	gint _tmp25_;
	guint _tmp26_;
	gboolean _tmp27_;
	g_return_if_fail (self != NULL);
	_tmp0_ = functions_tests_my_hashable_new (2);
	two = _tmp0_;
	_tmp1_ = functions_tests_my_hashable_new (1);
	one = _tmp1_;
	_tmp2_ = functions_tests_my_hashable_new (2);
	two_copy = _tmp2_;
	_tmp3_ = functions_tests_my_hashable_new (-1);
	minus_one = _tmp3_;
	_tmp4_ = functions_tests_my_hashable_new (-1);
	minus_one2 = _tmp4_;
	_tmp7_ = gee_functions_get_equal_func_for (FUNCTIONS_TESTS_TYPE_MY_HASHABLE, &_tmp5_, &_tmp6_);
	eq = _tmp7_;
	eq_target = _tmp5_;
	eq_target_destroy_notify = _tmp6_;
	_tmp10_ = gee_functions_get_compare_func_for (FUNCTIONS_TESTS_TYPE_MY_HASHABLE, &_tmp8_, &_tmp9_);
	cmp = _tmp10_;
	cmp_target = _tmp8_;
	cmp_target_destroy_notify = _tmp9_;
	_tmp13_ = gee_functions_get_hash_func_for (FUNCTIONS_TESTS_TYPE_MY_HASHABLE, &_tmp11_, &_tmp12_);
	hash = _tmp13_;
	hash_target = _tmp11_;
	hash_target_destroy_notify = _tmp12_;
	_vala_assert (eq != NULL, "eq != null");
	_vala_assert (cmp != NULL, "cmp != null");
	_vala_assert (hash != NULL, "hash != null");
	_tmp14_ = eq (two, two, eq_target);
	_vala_assert (_tmp14_, "eq (two, two)");
	_tmp15_ = cmp (two, two, cmp_target);
	_vala_assert (_tmp15_ == 0, "cmp (two, two) == 0");
	_tmp16_ = hash (two, hash_target);
	_tmp17_ = hash (two, hash_target);
	_vala_assert (_tmp16_ == _tmp17_, "hash (two) == hash (two)");
	_tmp18_ = eq (two, two_copy, eq_target);
	_vala_assert (_tmp18_, "eq (two, two_copy)");
	_tmp19_ = cmp (two, two_copy, cmp_target);
	_vala_assert (_tmp19_ == 0, "cmp (two, two_copy) == 0");
	_tmp20_ = hash (two, hash_target);
	_tmp21_ = hash (two_copy, hash_target);
	_vala_assert (_tmp20_ == _tmp21_, "hash (two) == hash (two_copy)");
	_tmp22_ = eq (one, two, eq_target);
	_vala_assert (!_tmp22_, "!eq (one, two)");
	_tmp23_ = cmp (one, two, cmp_target);
	_vala_assert (_tmp23_ < 0, "cmp (one, two) < 0");
	_tmp24_ = eq (two, one, eq_target);
	_vala_assert (!_tmp24_, "!eq (two, one)");
	_tmp25_ = cmp (two, one, cmp_target);
	_vala_assert (_tmp25_ > 0, "cmp (two, one) > 0");
	_tmp26_ = hash (one, hash_target);
	_vala_assert (_tmp26_ == ((guint) 1), "hash (one) == 1");
	_tmp27_ = eq (minus_one, minus_one2, eq_target);
	_vala_assert (!_tmp27_, "!eq (minus_one, minus_one2)");
	(hash_target_destroy_notify == NULL) ? NULL : (hash_target_destroy_notify (hash_target), NULL);
	hash = NULL;
	hash_target = NULL;
	hash_target_destroy_notify = NULL;
	(cmp_target_destroy_notify == NULL) ? NULL : (cmp_target_destroy_notify (cmp_target), NULL);
	cmp = NULL;
	cmp_target = NULL;
	cmp_target_destroy_notify = NULL;
	(eq_target_destroy_notify == NULL) ? NULL : (eq_target_destroy_notify (eq_target), NULL);
	eq = NULL;
	eq_target = NULL;
	eq_target_destroy_notify = NULL;
	_g_object_unref0 (minus_one2);
	_g_object_unref0 (minus_one);
	_g_object_unref0 (two_copy);
	_g_object_unref0 (one);
	_g_object_unref0 (two);
}


static Block8Data* block8_data_ref (Block8Data* _data8_) {
	g_atomic_int_inc (&_data8_->_ref_count_);
	return _data8_;
}


static void block8_data_unref (void * _userdata_) {
	Block8Data* _data8_;
	_data8_ = (Block8Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data8_->_ref_count_)) {
		FunctionsTests* self;
		self = _data8_->self;
		_g_object_unref0 (self);
		g_slice_free (Block8Data, _data8_);
	}
}


static Block9Data* block9_data_ref (Block9Data* _data9_) {
	g_atomic_int_inc (&_data9_->_ref_count_);
	return _data9_;
}


static void block9_data_unref (void * _userdata_) {
	Block9Data* _data9_;
	_data9_ = (Block9Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data9_->_ref_count_)) {
		FunctionsTests* self;
		self = _data9_->_data8_->self;
		block8_data_unref (_data9_->_data8_);
		_data9_->_data8_ = NULL;
		g_slice_free (Block9Data, _data9_);
	}
}


static gint __lambda55_ (Block9Data* _data9_) {
	Block8Data* _data8_;
	FunctionsTests* self;
	gint result = 0;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	_data8_ = _data9_->_data8_;
	self = _data8_->self;
	_tmp0_ = _data9_->k;
	_tmp1_ = _data8_->i;
	_vala_assert ((_tmp0_ + 1) == _tmp1_, "k + 1 == i");
	_tmp2_ = _data9_->k;
	_data8_->j = _tmp2_;
	_tmp3_ = _data9_->k;
	result = _tmp3_;
	return result;
}


static gpointer ___lambda55__gee_lazy_func (gpointer self) {
	gpointer result;
	result = (gpointer) ((gintptr) __lambda55_ (self));
	return result;
}


static GeeLazy* __lambda54_ (Block8Data* _data8_) {
	FunctionsTests* self;
	GeeLazy* result = NULL;
	Block9Data* _data9_;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	GeeLazy* _tmp4_;
	self = _data8_->self;
	_data9_ = g_slice_new0 (Block9Data);
	_data9_->_ref_count_ = 1;
	_data9_->_data8_ = block8_data_ref (_data8_);
	_tmp0_ = _data8_->j;
	_tmp1_ = _data8_->i;
	_vala_assert ((_tmp0_ + 1) == _tmp1_, "j + 1 == i");
	_tmp2_ = _data8_->i;
	if (_tmp2_ == 10) {
		result = NULL;
		block9_data_unref (_data9_);
		_data9_ = NULL;
		return result;
	}
	_tmp3_ = _data8_->i;
	_data8_->i = _tmp3_ + 1;
	_data9_->k = _tmp3_;
	_tmp4_ = gee_lazy_new (G_TYPE_INT, NULL, NULL, ___lambda55__gee_lazy_func, block9_data_ref (_data9_), block9_data_unref);
	result = _tmp4_;
	block9_data_unref (_data9_);
	_data9_ = NULL;
	return result;
}


static GeeLazy* ___lambda54__gee_unfold_func (gpointer self) {
	GeeLazy* result;
	result = __lambda54_ (self);
	return result;
}


void functions_tests_test_unfold (FunctionsTests* self) {
	Block8Data* _data8_;
	GeeIterator* iter = NULL;
	GeeIterator* _tmp0_;
	gint k = 0;
	gint _tmp10_;
	g_return_if_fail (self != NULL);
	_data8_ = g_slice_new0 (Block8Data);
	_data8_->_ref_count_ = 1;
	_data8_->self = g_object_ref (self);
	_data8_->i = 0;
	_data8_->j = -1;
	_tmp0_ = gee_iterator_unfold (G_TYPE_INT, NULL, NULL, ___lambda54__gee_unfold_func, block8_data_ref (_data8_), block8_data_unref, NULL);
	iter = _tmp0_;
	k = 0;
	while (TRUE) {
		GeeIterator* _tmp1_;
		gboolean _tmp2_;
		GeeIterator* _tmp3_;
		gpointer _tmp4_;
		gint _tmp5_;
		GeeIterator* _tmp6_;
		gpointer _tmp7_;
		gint _tmp8_;
		gint _tmp9_;
		_tmp1_ = iter;
		_tmp2_ = gee_iterator_next (_tmp1_);
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = iter;
		_tmp4_ = gee_iterator_get (_tmp3_);
		_tmp5_ = k;
		_vala_assert (((gint) ((gintptr) _tmp4_)) == _tmp5_, "iter.get () == k");
		_tmp6_ = iter;
		_tmp7_ = gee_iterator_get (_tmp6_);
		_tmp8_ = k;
		_vala_assert (((gint) ((gintptr) _tmp7_)) == _tmp8_, "iter.get () == k");
		_tmp9_ = k;
		k = _tmp9_ + 1;
	}
	_tmp10_ = k;
	_vala_assert (_tmp10_ == 10, "k == 10");
	_g_object_unref0 (iter);
	block8_data_unref (_data8_);
	_data8_ = NULL;
}


static Block10Data* block10_data_ref (Block10Data* _data10_) {
	g_atomic_int_inc (&_data10_->_ref_count_);
	return _data10_;
}


static void block10_data_unref (void * _userdata_) {
	Block10Data* _data10_;
	_data10_ = (Block10Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data10_->_ref_count_)) {
		FunctionsTests* self;
		self = _data10_->self;
		_g_object_unref0 (self);
		g_slice_free (Block10Data, _data10_);
	}
}


static Block11Data* block11_data_ref (Block11Data* _data11_) {
	g_atomic_int_inc (&_data11_->_ref_count_);
	return _data11_;
}


static void block11_data_unref (void * _userdata_) {
	Block11Data* _data11_;
	_data11_ = (Block11Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data11_->_ref_count_)) {
		FunctionsTests* self;
		self = _data11_->_data10_->self;
		block10_data_unref (_data11_->_data10_);
		_data11_->_data10_ = NULL;
		g_slice_free (Block11Data, _data11_);
	}
}


static GeeLazy* __lambda57_ (Block11Data* _data11_) {
	Block10Data* _data10_;
	FunctionsTests* self;
	GeeLazy* result = NULL;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	GeeLazy* _tmp3_;
	_data10_ = _data11_->_data10_;
	self = _data10_->self;
	_tmp0_ = _data11_->j;
	_tmp1_ = _data11_->start;
	if (_tmp0_ == (_tmp1_ + 3)) {
		result = NULL;
		return result;
	}
	_tmp2_ = _data11_->j;
	_data11_->j = _tmp2_ + 1;
	_tmp3_ = gee_lazy_new_from_value (G_TYPE_INT, NULL, NULL, (gpointer) ((gintptr) _tmp2_));
	result = _tmp3_;
	return result;
}


static GeeLazy* ___lambda57__gee_unfold_func (gpointer self) {
	GeeLazy* result;
	result = __lambda57_ (self);
	return result;
}


static GeeLazy* __lambda56_ (Block10Data* _data10_) {
	FunctionsTests* self;
	GeeLazy* result = NULL;
	Block11Data* _data11_;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	GeeIterator* iter = NULL;
	GeeIterator* _tmp3_;
	GeeIterator* _tmp4_;
	GeeLazy* _tmp5_;
	self = _data10_->self;
	_data11_ = g_slice_new0 (Block11Data);
	_data11_->_ref_count_ = 1;
	_data11_->_data10_ = block10_data_ref (_data10_);
	_tmp0_ = _data10_->i;
	if (_tmp0_ >= 3) {
		result = NULL;
		block11_data_unref (_data11_);
		_data11_ = NULL;
		return result;
	}
	_tmp1_ = _data10_->i;
	_data10_->i = _tmp1_ + 1;
	_data11_->j = _tmp1_ * 3;
	_tmp2_ = _data11_->j;
	_data11_->start = _tmp2_;
	_tmp3_ = gee_iterator_unfold (G_TYPE_INT, NULL, NULL, ___lambda57__gee_unfold_func, block11_data_ref (_data11_), block11_data_unref, NULL);
	iter = _tmp3_;
	_tmp4_ = iter;
	_tmp5_ = gee_lazy_new_from_value (GEE_TYPE_ITERATOR, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, _tmp4_);
	result = _tmp5_;
	_g_object_unref0 (iter);
	block11_data_unref (_data11_);
	_data11_ = NULL;
	return result;
}


static GeeLazy* ___lambda56__gee_unfold_func (gpointer self) {
	GeeLazy* result;
	result = __lambda56_ (self);
	return result;
}


void functions_tests_test_concat (FunctionsTests* self) {
	Block10Data* _data10_;
	GeeIterator* iter_ = NULL;
	GeeIterator* _tmp0_;
	gint j = 0;
	GeeIterator* iter = NULL;
	GeeIterator* _tmp1_;
	GeeIterator* _tmp2_;
	gint _tmp12_;
	gint _tmp13_;
	g_return_if_fail (self != NULL);
	_data10_ = g_slice_new0 (Block10Data);
	_data10_->_ref_count_ = 1;
	_data10_->self = g_object_ref (self);
	_data10_->i = 0;
	_tmp0_ = gee_iterator_unfold (GEE_TYPE_ITERATOR, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, ___lambda56__gee_unfold_func, block10_data_ref (_data10_), block10_data_unref, NULL);
	iter_ = _tmp0_;
	j = 0;
	_tmp1_ = iter_;
	_tmp2_ = gee_iterator_concat (G_TYPE_INT, NULL, NULL, _tmp1_);
	iter = _tmp2_;
	while (TRUE) {
		GeeIterator* _tmp3_;
		gboolean _tmp4_;
		gint _tmp5_;
		GeeIterator* _tmp6_;
		gpointer _tmp7_;
		gint _tmp8_;
		GeeIterator* _tmp9_;
		gpointer _tmp10_;
		gint _tmp11_;
		_tmp3_ = iter;
		_tmp4_ = gee_iterator_next (_tmp3_);
		if (!_tmp4_) {
			break;
		}
		_tmp5_ = j;
		_tmp6_ = iter;
		_tmp7_ = gee_iterator_get (_tmp6_);
		_vala_assert (_tmp5_ == ((gint) ((gintptr) _tmp7_)), "j == iter.get ()");
		_tmp8_ = j;
		_tmp9_ = iter;
		_tmp10_ = gee_iterator_get (_tmp9_);
		_vala_assert (_tmp8_ == ((gint) ((gintptr) _tmp10_)), "j == iter.get ()");
		_tmp11_ = j;
		j = _tmp11_ + 1;
	}
	_tmp12_ = _data10_->i;
	_vala_assert (_tmp12_ == 3, "i == 3");
	_tmp13_ = j;
	_vala_assert (_tmp13_ == 9, "j == 9");
	_g_object_unref0 (iter);
	_g_object_unref0 (iter_);
	block10_data_unref (_data10_);
	_data10_ = NULL;
}


static FunctionsTestsMyComparable* functions_tests_my_comparable_construct (GType object_type, gint i) {
	FunctionsTestsMyComparable * self = NULL;
	gint _tmp0_;
	self = (FunctionsTestsMyComparable*) g_object_new (object_type, NULL);
	_tmp0_ = i;
	self->priv->i = _tmp0_;
	return self;
}


static FunctionsTestsMyComparable* functions_tests_my_comparable_new (gint i) {
	return functions_tests_my_comparable_construct (FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, i);
}


static gint functions_tests_my_comparable_real_compare_to (GeeComparable* base, FunctionsTestsMyComparable* cmp) {
	FunctionsTestsMyComparable * self;
	gint result = 0;
	gint _tmp0_;
	FunctionsTestsMyComparable* _tmp1_;
	gint _tmp2_;
	self = (FunctionsTestsMyComparable*) base;
	g_return_val_if_fail (cmp != NULL, 0);
	_tmp0_ = self->priv->i;
	_tmp1_ = cmp;
	_tmp2_ = _tmp1_->priv->i;
	if (_tmp0_ == _tmp2_) {
		result = 0;
		return result;
	} else {
		gint _tmp3_;
		FunctionsTestsMyComparable* _tmp4_;
		gint _tmp5_;
		_tmp3_ = self->priv->i;
		_tmp4_ = cmp;
		_tmp5_ = _tmp4_->priv->i;
		if (_tmp3_ >= _tmp5_) {
			result = 1;
			return result;
		} else {
			result = -1;
			return result;
		}
	}
}


static void functions_tests_my_comparable_class_init (FunctionsTestsMyComparableClass * klass) {
	functions_tests_my_comparable_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FunctionsTestsMyComparablePrivate));
	G_OBJECT_CLASS (klass)->finalize = functions_tests_my_comparable_finalize;
}


static void functions_tests_my_comparable_gee_comparable_interface_init (GeeComparableIface * iface) {
	functions_tests_my_comparable_gee_comparable_parent_iface = g_type_interface_peek_parent (iface);
	iface->compare_to = (gint (*) (GeeComparable *, gconstpointer)) functions_tests_my_comparable_real_compare_to;
}


static void functions_tests_my_comparable_instance_init (FunctionsTestsMyComparable * self) {
	self->priv = FUNCTIONS_TESTS_MY_COMPARABLE_GET_PRIVATE (self);
}


static void functions_tests_my_comparable_finalize (GObject * obj) {
	FunctionsTestsMyComparable * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparable);
	G_OBJECT_CLASS (functions_tests_my_comparable_parent_class)->finalize (obj);
}


static GType functions_tests_my_comparable_get_type (void) {
	static volatile gsize functions_tests_my_comparable_type_id__volatile = 0;
	if (g_once_init_enter (&functions_tests_my_comparable_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FunctionsTestsMyComparableClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) functions_tests_my_comparable_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionsTestsMyComparable), 0, (GInstanceInitFunc) functions_tests_my_comparable_instance_init, NULL };
		static const GInterfaceInfo gee_comparable_info = { (GInterfaceInitFunc) functions_tests_my_comparable_gee_comparable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType functions_tests_my_comparable_type_id;
		functions_tests_my_comparable_type_id = g_type_register_static (G_TYPE_OBJECT, "FunctionsTestsMyComparable", &g_define_type_info, 0);
		g_type_add_interface_static (functions_tests_my_comparable_type_id, GEE_TYPE_COMPARABLE, &gee_comparable_info);
		g_once_init_leave (&functions_tests_my_comparable_type_id__volatile, functions_tests_my_comparable_type_id);
	}
	return functions_tests_my_comparable_type_id__volatile;
}


static FunctionsTestsMyHashable* functions_tests_my_hashable_construct (GType object_type, gint i) {
	FunctionsTestsMyHashable * self = NULL;
	gint _tmp0_;
	self = (FunctionsTestsMyHashable*) g_object_new (object_type, NULL);
	_tmp0_ = i;
	self->priv->i = _tmp0_;
	return self;
}


static FunctionsTestsMyHashable* functions_tests_my_hashable_new (gint i) {
	return functions_tests_my_hashable_construct (FUNCTIONS_TESTS_TYPE_MY_HASHABLE, i);
}


static gint functions_tests_my_hashable_real_compare_to (GeeComparable* base, FunctionsTestsMyHashable* cmp) {
	FunctionsTestsMyHashable * self;
	gint result = 0;
	gint _tmp0_;
	FunctionsTestsMyHashable* _tmp1_;
	gint _tmp2_;
	self = (FunctionsTestsMyHashable*) base;
	g_return_val_if_fail (cmp != NULL, 0);
	_tmp0_ = self->priv->i;
	_tmp1_ = cmp;
	_tmp2_ = _tmp1_->priv->i;
	if (_tmp0_ == _tmp2_) {
		result = 0;
		return result;
	} else {
		gint _tmp3_;
		FunctionsTestsMyHashable* _tmp4_;
		gint _tmp5_;
		_tmp3_ = self->priv->i;
		_tmp4_ = cmp;
		_tmp5_ = _tmp4_->priv->i;
		if (_tmp3_ >= _tmp5_) {
			result = 1;
			return result;
		} else {
			result = -1;
			return result;
		}
	}
}


static guint functions_tests_my_hashable_real_hash (GeeHashable* base) {
	FunctionsTestsMyHashable * self;
	guint result = 0U;
	gint _tmp0_;
	self = (FunctionsTestsMyHashable*) base;
	_tmp0_ = self->priv->i;
	result = (guint) _tmp0_;
	return result;
}


static gboolean functions_tests_my_hashable_real_equal_to (GeeHashable* base, FunctionsTestsMyHashable* hash) {
	FunctionsTestsMyHashable * self;
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	FunctionsTestsMyHashable* _tmp2_;
	gint _tmp3_;
	self = (FunctionsTestsMyHashable*) base;
	g_return_val_if_fail (hash != NULL, FALSE);
	_tmp1_ = self->priv->i;
	_tmp2_ = hash;
	_tmp3_ = _tmp2_->priv->i;
	if (_tmp1_ == _tmp3_) {
		gint _tmp4_;
		_tmp4_ = self->priv->i;
		_tmp0_ = _tmp4_ != -1;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


static void functions_tests_my_hashable_class_init (FunctionsTestsMyHashableClass * klass) {
	functions_tests_my_hashable_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FunctionsTestsMyHashablePrivate));
	G_OBJECT_CLASS (klass)->finalize = functions_tests_my_hashable_finalize;
}


static void functions_tests_my_hashable_gee_comparable_interface_init (GeeComparableIface * iface) {
	functions_tests_my_hashable_gee_comparable_parent_iface = g_type_interface_peek_parent (iface);
	iface->compare_to = (gint (*) (GeeComparable *, gconstpointer)) functions_tests_my_hashable_real_compare_to;
}


static void functions_tests_my_hashable_gee_hashable_interface_init (GeeHashableIface * iface) {
	functions_tests_my_hashable_gee_hashable_parent_iface = g_type_interface_peek_parent (iface);
	iface->hash = (guint (*) (GeeHashable *)) functions_tests_my_hashable_real_hash;
	iface->equal_to = (gboolean (*) (GeeHashable *, gconstpointer)) functions_tests_my_hashable_real_equal_to;
}


static void functions_tests_my_hashable_instance_init (FunctionsTestsMyHashable * self) {
	self->priv = FUNCTIONS_TESTS_MY_HASHABLE_GET_PRIVATE (self);
}


static void functions_tests_my_hashable_finalize (GObject * obj) {
	FunctionsTestsMyHashable * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashable);
	G_OBJECT_CLASS (functions_tests_my_hashable_parent_class)->finalize (obj);
}


static GType functions_tests_my_hashable_get_type (void) {
	static volatile gsize functions_tests_my_hashable_type_id__volatile = 0;
	if (g_once_init_enter (&functions_tests_my_hashable_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FunctionsTestsMyHashableClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) functions_tests_my_hashable_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionsTestsMyHashable), 0, (GInstanceInitFunc) functions_tests_my_hashable_instance_init, NULL };
		static const GInterfaceInfo gee_comparable_info = { (GInterfaceInitFunc) functions_tests_my_hashable_gee_comparable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		static const GInterfaceInfo gee_hashable_info = { (GInterfaceInitFunc) functions_tests_my_hashable_gee_hashable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType functions_tests_my_hashable_type_id;
		functions_tests_my_hashable_type_id = g_type_register_static (G_TYPE_OBJECT, "FunctionsTestsMyHashable", &g_define_type_info, 0);
		g_type_add_interface_static (functions_tests_my_hashable_type_id, GEE_TYPE_COMPARABLE, &gee_comparable_info);
		g_type_add_interface_static (functions_tests_my_hashable_type_id, GEE_TYPE_HASHABLE, &gee_hashable_info);
		g_once_init_leave (&functions_tests_my_hashable_type_id__volatile, functions_tests_my_hashable_type_id);
	}
	return functions_tests_my_hashable_type_id__volatile;
}


static void functions_tests_class_init (FunctionsTestsClass * klass) {
	functions_tests_parent_class = g_type_class_peek_parent (klass);
}


static void functions_tests_instance_init (FunctionsTests * self) {
}


GType functions_tests_get_type (void) {
	static volatile gsize functions_tests_type_id__volatile = 0;
	if (g_once_init_enter (&functions_tests_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FunctionsTestsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) functions_tests_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionsTests), 0, (GInstanceInitFunc) functions_tests_instance_init, NULL };
		GType functions_tests_type_id;
		functions_tests_type_id = g_type_register_static (GEE_TYPE_TEST_CASE, "FunctionsTests", &g_define_type_info, 0);
		g_once_init_leave (&functions_tests_type_id__volatile, functions_tests_type_id);
	}
	return functions_tests_type_id__volatile;
}



